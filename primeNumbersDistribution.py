# -*- coding: utf-8 -*-
"""primeNumbersDistribution.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hiBg7hLClOtAwb66UpPGUQcUA7I2NP3S

# Prime numbers distribution prediction
This is a project for creating an algorithm using a Q-Learning model for predicting the distribution of prime numbers using most simple operations as possible.

## Incipit
The entire project is based on a simple probability formula:
$notPrimePredictProb = (\frac{1}{n}*(1-notPrimePredictProb))+notPrimePredictProb$

The concept is: you can obtain the statistic prediction of not prime numbers and, by consequence, of prime numbers updating this formula for each prime number. This probability is valid until the next prime number found, so the intent of this project is finding the right algorithm which can use this simple concept for forecast with more precision as possible the prime numbers distribution from 2 to *n*.

Were tested many combinations of algorithms which, using this base formula, can obtain a pretty plausible probability distribution, although not able to predict the right prime numbers in the long term of the cycles.

These promising results led me to work to this Tensorflow-based Q-Learning model which aims to generate the algorithm able to have the best result in the calc of the distribution of prime numbers.

For simplicity and performance rapidity, the project could begin to evaluate numbers from 2 to 10.000, maybe adding a zero per advancement.

## Collaborators
Ideated by Riccardo Cecchini \<rcecchini.ds@gmail.com>

# Base code requirements

Imports:
"""

import os
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.image as img
from random import sample
from keras import backend as K

from keras.models import Sequential, Model
from keras.layers import Dense, Flatten, Input, Lambda, BatchNormalization, Reshape, GRU, Conv2D, MaxPooling2D, LSTM
from keras.layers import Activation, Concatenate, AveragePooling2D, GlobalAveragePooling2D, TimeDistributed
from keras.optimizers import Adam

import tensorflow as tf

import random
import math

import json

"""## Costum classes"""

myFloat = np.double
if hasattr(np, 'float128'):
    myFloat = np.float128

"""First, calculate prime numbers up to `upTo`, beginning from 2."""

def is_prime(num):
  if num < 2:
    return False
  for i in range(2, int(num ** 0.5) + 1):
    if num % i == 0:
      return False
  return True

upTo = 10000 # 10.000

numIsPrime = []

prime_numbers = []
count = 0
num = 2

while num <= upTo:
  if is_prime(num):
    prime_numbers.append(num)
    numIsPrime.append(True)
  else:
    numIsPrime.append(False)

  num += 1

print("First "+ str(upTo) +" numbers calculated")

"""Then calculate distribution"""

distribution = []
numPrimes = 0
nextPrime = prime_numbers[numPrimes]

n = 2
while n <= upTo:
  if nextPrime == n:
    numPrimes += 1
    if len(prime_numbers) > numPrimes:
      nextPrime = prime_numbers[numPrimes]
    else:
      nextPrime += upTo

  distribution.append(numPrimes)
  n += 1

print("Distribution calculated (",len(distribution),")")

"""# Q-Learning library

Forking code from https://github.com/farizrahman4u/qlearning4k
"""

batch_size = 30

class Agent:

  def __init__(self, model, memory=None, nb_frames=None):
    self.input_shape = model.input_shape[1:]
    print("input_shape: ", self.input_shape)

    self.output_shape = model.layers[-1].output_shape[1:]
    print("output_shape: ", self.output_shape)
    #assert len(output_shape) == 2, "Model's output shape should be (nb_samples, nb_actions)."

    self.fileTraining = 'lastTraining.json'

    self.fileWeights = 'weights.dat'
    if(os.path.exists(self.fileWeights)):
      model.load_weights(self.fileWeights)

    if memory:
      self.memory = memory
    else:
      self.memory = ExperienceReplay(self.input_shape)
    if not nb_frames and not model.layers[1].input_shape:
      raise Exception("Missing argument : nb_frames not provided")
    elif not nb_frames:
      nb_frames = model.layers[0].input_shape[0]
    elif model.layers[1].input_shape and nb_frames and model.layers[1].input_shape != nb_frames:
      raise Exception("Dimension mismatch : time dimension of model should be equal to nb_frames.")
    self.model = model
    self.nb_frames = nb_frames
    self.frames = None

  @property
  def memory_size(self):
    return self.memory.memory_size

  @memory_size.setter
  def memory_size(self, value):
    self.memory.memory_size = value

  def reset_memory(self):
    self.exp_replay.reset_memory()

  def check_game_compatibility(self, game):
    return # check temporarly disabled

    game_output_shape = (1, None) + game.get_frame().shape
    if len(game_output_shape) != len(self.model.layers[0].output_shape[0]):
      print('game_output_shape: ', game_output_shape)
      print('layer[0].output_shape', self.model.layers[0].output_shape)
      raise Exception('Dimension mismatch. Input shape of the model should be compatible with the game.')
    else:
      for i in range(len(self.model.layers[0].input_shape)):
        if self.model.layers[i].output_shape and game_output_shape[i] and self.model.layers[i].output_shape[0] != game_output_shape[i]:
          print("Err on self.model.layers[i].output_shape[0]", self.model.layers[i].output_shape[0])
          raise Exception('Dimension mismatch. Input shape of the model should be compatible with the game.')
    if len(self.model.layers[0].output_shape) != 2 or self.model.layers[1].output_shape != game.nb_actions:
      raise Exception('Output shape of model should be (nb_samples, nb_actions).')

  def get_game_data(self, game):
    frame = game.get_frame()
    return frame

    # Deprecated
    if self.frames is None:
      self.frames = []

    if len(self.frames) > 0: # buh
        self.frames.pop(0)

    self.frames.append(frame)

    return np.expand_dims(self.frames, 0)

  def clear_frames(self):
    self.frames = None

  def saveJson(self, file, var):
    f = open(file, "w")
    f.write(json.dumps(var))
    f.close()

  def readJson(self, file):
    if(os.path.exists(file)):
      f = open(file, "r")
      return json.loads(f.read())
    return None

  def train(self, game, nb_epoch=1000, gamma=0.9, epsilon=[1., .1], epsilon_rate=0.5, reset_memory=False, observe=0, checkpoint=10):
    self.check_game_compatibility(game)

    if type(epsilon)  in {tuple, list}:
      delta =  ((epsilon[0] - epsilon[1]) / (nb_epoch * epsilon_rate))
      final_epsilon = epsilon[1]
      epsilon = epsilon[0]
    else:
      final_epsilon = epsilon

    model = self.model
    nb_actions = model.layers[-1].output_shape[0]
    win_count = 0

    observeModel = False
    totEpochs = nb_epoch
    minEpochsControl = totEpochs / 10

    epoch = 0

    lastTrain = self.readJson(self.fileTraining)
    if lastTrain != None:
      delta = lastTrain['delta']
      epsilon = lastTrain['epsilon']
      final_epsilon = lastTrain['final_epsilon']
      epoch = lastTrain['epoch']
      nb_epoch = lastTrain['nb_epoch']
      observeModel = lastTrain['observeModel']

    while epoch < nb_epoch:
      epoch += 1

      loss = 0.
      accuracy = 0.

      game.reset()
      self.clear_frames()

      if reset_memory:
        self.reset_memory()

      game_over = False
      S = self.get_game_data(game)

      cycles = 0
      while not game_over:
        cycles += 1

        if np.random.random() < epsilon or epoch < observe:
          a = int(np.random.randint(game.nb_actions))
        else:
          q = model.predict(np.array([S]))
          q = q[0]
          a = int(np.argmax(q))

        game.play(a)
        r = game.get_score()
        S_prime = self.get_game_data(game)
        game_over = game.is_over()
        transition = [S, a, r, S_prime, game_over]
        self.memory.remember(*transition)
        S = S_prime

        if epoch >= observe:
          batch = self.memory.get_batch(model=model, batch_size=batch_size, gamma=gamma)

          if batch:
            inputs, targets = batch
            train = model.train_on_batch(inputs, targets)
            loss += float(train)
            #accuracy += float(train[1])

        if checkpoint and ((epoch + 1 - observe) % checkpoint == 0 or epoch >= nb_epoch):
          model.save_weights(self.fileWeights)

          save = {
              'delta': delta,
              'epsilon': epsilon,
              'final_epsilon': final_epsilon,
              'epoch': epoch,
              'nb_epoch': nb_epoch,
              'observeModel': observeModel
          }
          self.saveJson(self.fileTraining, save)

      if game.is_won():
        win_count += 1

      if epsilon > final_epsilon and epoch >= observe:
        epsilon -= delta

        if not observeModel and epsilon < delta:
          if (nb_epoch - epoch) < minEpochsControl:
            nb_epoch = minEpochsControl
            epoch = 0
          observeModel = True

      loss /= cycles
      loss /= upTo

      accuracy /= cycles

      print("=========================================")
      print("Epoch {:03d}/{:03d} | Loss {:.4f} | Epsilon {:.2f} | Win count {}".format(epoch + 1, nb_epoch, loss, epsilon, win_count))
      print("=========================================")

      K.clear_session() # try to reduce RAM usage

  def play(self, game, nb_epoch=10, epsilon=0., visualize=False):
    self.check_game_compatibility(game)
    model = self.model
    win_count = 0
    frames = []

    for epoch in range(nb_epoch):
      game.reset()
      self.clear_frames()
      S = self.get_game_data(game)

      if visualize:
        frames.append(game.draw())

      game_over = False
      while not game_over:
        if np.random.rand() < epsilon:
          print("random")
          action = int(np.random.randint(0, game.nb_actions))
        else:
          q = model.predict(np.array([S]))
          q = q[0]

          possible_actions = game.get_possible_actions()
          q = [q[i] for i in possible_actions]
          action = possible_actions[np.argmax(q)]

        game.play(action)
        S = self.get_game_data(game)

        if visualize:
          frames.append(game.draw())

        game_over = game.is_over()

      if game.is_won():
        win_count += 1

    print("Accuracy {} %".format(100. * win_count / nb_epoch))

    if visualize and False: #todo: handle this possibility on colab
      if 'images' not in os.listdir('.'):
        os.mkdir('images')
      for i in range(len(frames)):
        plt.imshow(frames[i], interpolation='none')
        plt.savefig("images/" + game.name + str(i) + ".png")

###
### Memory
###
class Memory:

    def __init__(self):
        pass

    def remember(self, S, a, r, S_prime, game_over):
        pass

    def get_batch(self, model, batch_size):
        pass


class ExperienceReplay(Memory):

    def __init__(self, input_shape):
        self.input_shape = input_shape
        self.memory = []
        self.orderedMemory = []
        self._memory_size = batch_size

    def remember(self, s, a, r, s_prime, game_over):
        self.orig_input_shape = s.shape

        # Remove superfluous actions
        if len(self.memory) > 0:
          prev = len(self.orderedMemory)-1
          prevA = self.orderedMemory[prev]
          if prevA == 0: # it's action "down"
            self.memory.pop(prev)
            self.orderedMemory.pop(prev)

        concat = np.concatenate([s.flatten(), np.array(a).flatten(), np.array(r).flatten(), s_prime.flatten(), 1 * np.array(game_over).flatten()])
        self.memory.append(concat)
        self.orderedMemory.append([a])

        if self.memory_size > 0 and len(self.memory) > self.memory_size:
          self.memory.pop(0)
          self.orderedMemory.pop(0)

    def get_batch(self, model, batch_size, gamma=0.9):
      memLen = len(self.memory)

      nb_actions = model.layers[-1].output_shape[-1]

      samples = np.array(sample(self.memory, memLen))

      input_dim = np.prod(self.orig_input_shape)
      S = samples[:, 0 : input_dim]
      a = samples[:, input_dim]
      r = samples[:, input_dim + 1]
      S_prime = samples[:, input_dim + 2 : 2 * input_dim + 2]

      r = r.repeat(nb_actions).reshape((memLen, nb_actions))

      S = S.reshape((memLen, ) + self.orig_input_shape)
      S_prime = S_prime.reshape((memLen, ) +self.orig_input_shape)

      X = np.concatenate([S, S_prime], axis=0)
      Y = model.predict(X)

      if(math.isnan(Y[0][0])):
        raise Exception("Prediction is broken :(")

      ybs_ = Y[memLen:]
      Qsa = np.max(ybs_, axis=1).repeat(nb_actions).reshape((memLen, nb_actions))

      y_bs = Y[:memLen]
      y_bs_rs = np.max(y_bs, axis=1).repeat(nb_actions).reshape((memLen, nb_actions))

      a = np.cast['int'](a)
      delta = np.zeros((memLen, nb_actions))
      deltaMinSize = 1 # int(y_bs_rs.shape[0] / len(a))

      for i in range(0, len(a)):
        deltaPiece = np.zeros((deltaMinSize, nb_actions))
        aa = np.array([a[i]])
        arange = np.arange(deltaMinSize)
        deltaPiece[arange, aa] = 1
        delta[i] = deltaPiece

      '''
      # Original algorithm:
      game_over = samples[:, 2 * input_dim + 2]
      game_over = game_over.repeat(nb_actions).reshape((memLen, nb_actions))
      r = r.reshape((memLen, nb_actions))
      r /= upTo
      rgo = r + gamma * (1 - game_over)
      targets = (1 - delta) * y_bs_rs + delta * (rgo * Qsa)
      '''

      r = r.reshape((memLen, nb_actions))

      avgPredict = (y_bs_rs + Qsa)/2 # I don't know if it has really sense
      deltaMin = 1 - delta

      targets = (deltaMin * avgPredict) + (delta * r)

      return S, targets

    @property
    def memory_size(self):
        return self._memory_size

    @memory_size.setter
    def memory_size(self, value):
        if value > 0 and value < self._memory_size:
            self.memory = self.memory[:value]
        self._memory_size = value

    def reset_memory(self):
        self.memory = []

    def  one_hot(self, seq, num_classes):
        return K.one_hot(K.reshape(K.cast(seq, "int32"), (-1, 1)), num_classes)


###
### Game parent class
###

class Game(object):

  def __init__(self):
    self.reset()

  @property
  def name(self):
    return "Game"

  @property
  def nb_actions(self):
    return 0

  def reset(self):
    pass

  def play(self, action):
    pass

  def get_state(self):
    return None

  def get_score(self):
    return 0

  def is_over(self):
    return False

  def is_won(self):
    return False

  def get_frame(self):
    return self.get_state()

  def draw(self):
    return self.get_state()

  def get_possible_actions(self):
    return range(self.nb_actions)

"""An example of implementation of Game class could be found here: https://github.com/farizrahman4u/qlearning4k/blob/master/qlearning4k/games/snake.py

# How works
The "game" we will create is based on fixed cycles, some costants and fixed variables that the machine can interpret and alter using the operations at its disposition, with the possibility to use additional variables.

The game looks like a vim editor and its input is represented by integers. The virtual screen is represented by a scrollable grid where every "pixel" is represented by an array of 3 items: **isSelected**, **class**, **value**.
- **isSelected**: 0 normally, 1 if the focus is on this element.
- **class**: The type of the value. 0 for labels, 1 for numbers.
- **value**: The ID of the label or the value of the number.

## Possible actions
- **right**: Move the cursor on the right
- **down**: Change the current pixel to the next value

## Variables and costants rappresentation
Are used two pixels for representing a store: the type and the value.
The type: in the labeling point of view is composed by two chars, representing the type of the store, if it's a decimal or a boolean (d or b), and if it's a constant or a variable (# or \$).

The value it's the position of the store in the stack.

- For example a decimal constant at position 2 is written: `d# 2`
- A boolean variable at position 1 is written: `b$ 1`

The total store type are finally 4:
1.   `d#`
2.   `b#`
3.   `d$`
4.   `b$`

## Instruction representation
A line is used to represent an instruction. It's composed by:
`lineNumber storeValueTo operation storeArg1 storeArg2`

An example could be a sum:
`1 d$1 SUM d$0 d#2 `, which is the equivalent of `d$1 = d$0 + d#2`

During the selection of the first store is possible to select just variables or the label `IF`. In this last case the continuation of the instruction change radically: in fact after an IF there is just the store boolean.

Totally, a line is at a maximum long 8 pixels.

## IF and END statements
`IF` and `END` statements are unique instructions different than normal operations lines.
In fact they take just zero or one argument, meaning the boolean store which conditions the behavior of the `IF`. During the writing of the `IF` the next instructions enter in a new context. For exiting from current context is necessary to use the `exit` action, which set the next line to `END` instruction. The `END` instruction could be also used for ending the entire script.

## Loops
For the moment loops are not supported, but they could be necessary for more precision in the best result possible. Anyway, it's a complication which must be handled delicately.

## The cycle
The cycle is composed by these variable (this is pseudo-code)

```
decimal #zero = 0
decimal #one = 1

bool #false = false
bool #true = true

decimal #step = 2 // the cycle starts from 2
decimal #i // #step - 1
decimal #numPrimes = 0 // the current number of found primes
decimal #lastPrime = 0 // the difference between the current step and the last found prime

decimal #primeProb = 0 // the current probability of a prime in the stack
decimal #notPrimeProb = 1 // 1 - #primeProb

decimal #predictedNotPrimeProb = 0 // the predicted probability of a not prime
decimal #predictedPrimeProb // 1 - #predictedNotPrimeProb

// Calculate #predictedNotPrimeProb if it's a prime
decimal #ifPrimePredictNotPrimeProb
decimal #ifPrimePredictPrimeProb

decimal #quanto // 1 / step

bool $isPrime = false

while(#step < upTo){

  #i = step - 1  
  #quanto = 1 / #step

  #ifPrimePredictNotPrimeProb = #predictedNotPrimeProb
  if (#ifPrimePredictNotPrimeProb == 0){
      #ifPrimePredictNotPrimeProb = #quanto
  }
  else {
      decimal primeStamp = #quanto
      primeStamp *= #predictedPrimeProb
      #ifPrimePredictNotPrimeProb += primeStamp
  }    

  decimal #ifPrimePredictPrimeProb = 1 - #ifPrimePredictNotPrimeProb

  ///////////////////////////////////////
  /////////// GAME CONTENT //////////////
  ///////////////////////////////////////

  if($isPrime){
    #numPrimes += 1
    #lastPrime = 0

    #predictedNotPrimeProb = #ifPrimePredictNotPrimeProb
    #predictedPrimeProb = #ifPrimePredictPrimeProb
  }

  #primeProb = #numPrimes / #i
  #notPrimeProb = 1 - #primeProb

  #lastPrime += 1
  #step += 1
}

```

### Additional stores
These are stores which can be added later.



```
decimal #probNextPrime
decimal #probNextNotPrime
decimal #predictNextPrime
decimal #predictNextNotPrime

decimal #nextPrime = 0
decimal #nextNotPrime = 0

cycle {

  #probNextPrime = 1 / #primeProb
  #probNextNotPrime = 1 / (1 - #primeProb)
  #predictNextPrime = 1 / #predictedPrimeProb
  #predictNextNotPrime = 1 / #predictedNotPrimeProb

  //////// STUFF //////////

  if($isPrime){
    #nextPrime += #predictNextPrime
    #nextNotPrime -= 1
  }
  else {
    #nextNotPrime += #predictNextNotPrime
    #nextPrime -= 1
  }
}
```

## Labels
"""

labels = []

storeTypes = []
storeTypes.append('d#')
storeTypes.append('b#')
storeTypes.append('d$')
storeTypes.append('b$')
labels.extend(storeTypes)

alternativeStartInstruction = ['IF', 'END']
labels.extend(alternativeStartInstruction)

"""## Operations

Divided by the type returned

### Neutral
- `ASSIGN`: store's value assigned to another store
- `DEFAULT`: if the assign variable doesn't exists, set the argument value

They both take just 1 argument of the same type.

### Decimal:
- `ADD`: addition
- `SUB`: subtract
- `MUL`: multiply
- `DIV`: divide

### Boolean:
- `NOT`: invert bool value [boolean]
- `CMP`: compare
- `GT`: great than [decimal]
- `GET`: great or equal than [decimal]

#### Removed:
- `LT`: less than [decimal]
- `LET`: less or equal than [decimal]

The reason of `LT` and `LET` removement it's that the same result could be obtained with an `GT` and `GET` inverting the arguments order.

"""

neutralOps = ['ASSIGN', 'DEFAULT']
labels.extend(neutralOps)

decimalOps = []
decimalOps.append('ADD')
decimalOps.append('SUB')
decimalOps.append('MUL')
decimalOps.append('DIV')
labels.extend(decimalOps)

boolOps = []
boolOps.append('NOT')
boolOps.append('CMP')
boolOps.append('GT')
boolOps.append('GET')
#boolOps.append('LT')
#boolOps.append('LET')
labels.extend(boolOps)

boolOps_bool = ['NOT']
boolOps_decimal = ['GT', 'GET', 'LT', 'LET']

oneArgOps = ['NOT']

"""# Default costants and variables


"""

storesNames = {}
storesNamesAssoc = {}
stores = {}

def assocNames(names, storeType):
  storesNames[storeType] = names
  stores[storeType] = []

  for name in names:
    storesNamesAssoc[name] = storeType

boolCostNames = [
    'false',
    'true'
]

boolVarsNames = [
    #'isPrime'
]

decimalCostNames = [
    'zero',
    'one',
    'step',
    'i',
    'numPrimes',
    'lastPrime',
    'primeProb',
    'notPrimeProb',
    'predictedNotPrimeProb',
    'predictedPrimeProb',
    'ifPrimePredictNotPrimeProb',
    'ifPrimePredictPrimeProb',
    'quanto'
]

decimalVarsNames = []

def resetStores():
  storesNames = {}
  storesNamesAssoc = {}
  stores = {}

  assocNames(boolCostNames, 'b#')
  assocNames(boolVarsNames, 'b$')
  assocNames(decimalCostNames, 'd#')
  assocNames(decimalVarsNames, 'd$')

resetStores()

def getNameType(name):
  if name in storesNamesAssoc:
    return storesNamesAssoc[name]
  else:
    return None

def setStore(name, value):
    isCost = name.startswith('#')
    name = name[1:]

    isBool = isinstance(value, bool)

    storeTypeSaved = getNameType(name)

    storeType = ''
    if isBool:
      storeType += 'b'
    else:
      storeType += 'd'

    if isCost:
      storeType += '#'
    else:
      storeType += '$'

    typeNames = None
    pos = -1

    if storeTypeSaved is not None:
      if storeTypeSaved != storeType:
        raise Exception("Excepted store of type " + storeTypeSaved + ", received " + storeType)

      typeNames = storesNames[storeType]
      pos = typeNames.index(name)

    else:
      typeNames = storesNames[storeType]

      pos = len(typeNames)
      typeNames.append(name)
      storesNamesAssoc[name] = storeType

    if not isBool and not isinstance(value, myFloat):
      value = myFloat(value)

    st = stores[storeType]

    if len(st) <= pos:
      st.append(value)
    else:
      st[pos] = value

def getStore(name):
  isCost = name.startswith('#')
  isVar = name.startswith('$')

  if isCost or isVar:
    name = name[1:]

  storeTypeSaved = getNameType(name)

  if storeTypeSaved is None:
    raise Exception("Store "+name+" not found")

  typeNames = storesNames[storeTypeSaved]
  pos = typeNames.index(name)

  return stores[storeTypeSaved][pos]

def setStoreFields(fields, value):
  storeType = fields[0]
  pos = fields[1]

  reqBool = storeType.startswith('b')
  if reqBool:
      try:
          value = bool(value)
      except:
          print('neu')

  valBool = isinstance(value, bool)

  if reqBool != valBool:
    raise Exception("Different type assignation for ",storeType, " (valueIsBool:",valBool,", reqBool:",reqBool,", value:",value,")");

  if not valBool and not isinstance(value, myFloat):
    value = myFloat(value)

  st = stores[storeType]

  if len(st) <= pos:
    st.append(value)
  else:
    st[pos] = value

def getStoreFields(fields):
  if len(fields) != 2:
    print("Error: as fields I got a ", fields)

  storeType = fields[0]
  pos = fields[1]

  if not checkStoreFields(fields):
    print("Error for fields", fields, stores[storeType])
    if storeType.startswith('d'):
        return 0
    else:
        return False

  return stores[storeType][pos]

def checkStoreFields(fields):
  storeType = fields[0]
  pos = fields[1]

  return pos < len(stores[storeType])

"""# Engine
This is the engine that interpret commands and executes the cycles.
"""

def fieldIsStore(f):
  return f in storeTypes

def instructionsToByteCode(instructions):
  res = []
  parent = []
  context = res
  end = False

  for instr in instructions:
    if end:
      break

    resInstr = []

    acc = '' # accumuling
    nextIsStore = False
    isCondition = False

    def addToResInstr(val):
      if isCondition:
        resInstr['condition'] = val
      else:
        resInstr.append(val)

    for f in range(0, len(instr)):
      field = instr[f]

      if field == '': # it depends how is done the instruction array
        break

      #print('Reading field ',field, nextIsStore)

      if f == 0: # if it's the first field of the line
        if field == 'IF':
          resInstr = {'statement': field, 'condition':[], 'context': []}
          isCondition = True
          context.append(resInstr)
          parent.append(context)
          context = resInstr['context']
          continue

        if field == 'END':
          if len(parent) == 0:
            end = True
            break

          context = parent.pop()

      if not nextIsStore: # is not store second value
        nextIsStore = fieldIsStore(field)

        if not nextIsStore:
          addToResInstr([field]) # add normally
        else:
          acc = field # accumulate store first value for next field
      else: # is store second value
        addToResInstr([acc, field])
        nextIsStore = False

    if not isCondition: # if it's a condition it's already added to context
      context.append(resInstr)

  return res

###
### Interpret bytecode
###

def interpretBytecode_condition(condition):
  #print('Condition: ', condition)
  match condition['statement']:
    case 'IF':
      if getStoreFields(condition['condition']):
        interpretBytecode(condition['context'])

    case _:
      raise Exception("Condition "+condition['statement']+" not found")

def interpretBytecode_line(line):
  lineLen = len(line)

  if lineLen == 0:
    return

  if lineLen < 3:
    cmd = line[0][0]

    if cmd == 'END':
      return #todo: Handle better the END command

  assignTo = line[0]

  operation = line[1][0]
  arg1 = getStoreFields(line[2])

  if lineLen > 3:
    arg2 = getStoreFields(line[3])

  # Here there is not control about the right type used for the operation:
  # it's assumed that Calculon automatically removed wrong types from selectionable options

  write = True
  res = None
  match operation:
    # Neutral
    case 'ASSIGN':
      res = arg1

    case 'DEFAULT':
      res = arg1
      write = not checkStoreFields(assignTo)

    # Decimal
    case 'ADD':
      res = arg1 + arg2

    case 'SUB':
      res = arg1 - arg2

    case 'MUL':
      res = arg1 * arg2

    case 'DIV':
      if arg2 == 0:
        res = 0 # wrong but temporary response
        #todo: Handle this condition blocking the game
      else:
        res = arg1 / arg2

    # Bool
    case 'NOT':
      res = not arg1

    case 'CMP':
      res = arg1 == arg2

    case 'GT':
      res = arg1 > arg2

    case 'GET':
      res = arg1 >= arg2

    case _:
      raise Exception('Operation '+ operation +' not found')

  if write:
    setStoreFields(assignTo, res)

def interpretBytecode(bytecode):
  for line in bytecode:
    isCondition = isinstance(line, dict)

    if isCondition:
      interpretBytecode_condition(line)
    else:
      interpretBytecode_line(line)

###
### Execute Cycles
###

def resetEngine():
  resetStores()

  setStore('#zero', 0)
  setStore('#one', 1)

  setStore('#false', False)
  setStore('#true', True)

  setStore('#step', 2)
  setStore('#i', 1)

  setStore('#numPrimes', 0)
  setStore('#lastPrime', 0)

  setStore('#primeProb', 0)
  setStore('#notPrimeProb', 1)

  setStore('#predictedNotPrimeProb', 0)
  setStore('#predictedPrimeProb', 1)

  setStore('#ifPrimePredictNotPrimeProb', 0)
  setStore('#ifPrimePredictPrimeProb', 0)

  setStore('#quanto', 1)

  #setStore('$isPrime', False)

resetEngine() # reset by default

def executeCycles(instructions, isPrimeVar=0):
  bytecode = instructionsToByteCode(instructions)

  resetEngine()

  # Score variables
  distributionDiff = 0
  distributionMaxDiff = 0

  # Cache stores
  step = getStore('#step')
  i = getStore('#i')
  quanto = None
  ifPrimePredictNotPrimeProb = None
  ifPrimePredictPrimeProb = None
  predictedPrimeProb = getStore('#predictedPrimeProb')
  predictedNotPrimeProb = getStore('#predictedNotPrimeProb')
  isPrime = None
  numPrimes = getStore('#numPrimes')
  lastPrime = getStore('#lastPrime')

  while(step <= upTo):
    i = step-1
    quanto = 1/step

    ifPrimePredictNotPrimeProb = getStore('#predictedNotPrimeProb')

    # Calculate if prime prediction probability
    primeStamp = quanto
    primeStamp *= predictedPrimeProb
    ifPrimePredictNotPrimeProb += primeStamp
    ifPrimePredictPrimeProb = 1 - ifPrimePredictNotPrimeProb

    setStore('#i', i)
    setStore('#quanto', quanto)
    setStore('#ifPrimePredictNotPrimeProb', ifPrimePredictNotPrimeProb)
    setStore('#ifPrimePredictPrimeProb', ifPrimePredictPrimeProb)

    ###
    ### Cycle
    ###

    interpretBytecode(bytecode)

    ###
    ### End cycle
    ###

    isPrime = getStoreFields(['b$', isPrimeVar])

    if isPrime:
      numPrimes += 1
      lastPrime = 0

      predictedNotPrimeProb = ifPrimePredictNotPrimeProb
      predictedPrimeProb = ifPrimePredictPrimeProb

    primeProb = numPrimes / i
    notPrimeProb = 1 - primeProb

    lastPrime += 1
    step += 1

    setStore('#numPrimes', numPrimes)
    setStore('#lastPrime', lastPrime)
    setStore('#predictedNotPrimeProb', predictedNotPrimeProb)
    setStore('#predictedPrimeProb', predictedPrimeProb)
    setStore('#primeProb', primeProb)
    setStore('#notPrimeProb', notPrimeProb)
    setStore('#step', step)

    # Add score
    i = int(i)
    effectiveNumPrimes = distribution[i-1]
    numPrimesDiff = numPrimes - effectiveNumPrimes

    if numPrimesDiff < 0:
      numPrimesDiff /= effectiveNumPrimes
      numPrimesDiff *= -1
      distributionDiff += numPrimesDiff

    elif numPrimesDiff > 0:
      numPrimesDiff /= i - effectiveNumPrimes
      distributionDiff += numPrimesDiff

    distributionMaxDiff += 1

  distributionDiff /= distributionMaxDiff
  return (1 - distributionDiff)*upTo

"""# The 'game'
This is the implementation of *Game* class for implementing the IDE. This 'game' is called Calculon.
"""

actions = {0:'right', 1:'down'}
ideWidth = 7

# Game options
drawLineNumber = False
dontAllowEndOnDepth0 = True

rewardVars = [
    #['b$', storesNames['b$'].index('isPrime'), 3],
    ['d#', storesNames['d#'].index('primeProb')],
    ['d#', storesNames['d#'].index('predictedPrimeProb')],
    ['d#', storesNames['d#'].index('lastPrime')]
]

def cloneDictOfArr(arr):
  res = {}
  for i in arr:
    res[i] = arr[i].copy()
  return res

def checkVarReward(stype, num=-1):
  reward = 0
  for var in rewardVars:
    if num >= -1:
      if stype == var[0] and num == var[1]:
        varReward = 1
        if len(var) > 2:
          varReward = var[2]
        return varReward
    else:
        if stype == var[0]:
            reward += 1
            return 1 # disable store type reward weight
  return reward


class Calculon(Game):

  def __init__(self, num_lines=500):
    self.num_lines = num_lines
    self.reset()
    self.state_changed = True

    self.maxScore = 0
    self.maxScoreLen = 0

    self.ideWidth = ideWidth
    if drawLineNumber:
      self.ideWidth += 1

  @property
  def name(self):
    return "Calculon"
  @property
  def nb_actions(self):
    return 2

  def play(self, action):
    if action not in range(self.nb_actions):
      print('Called wrong action: ', action)
      self.currentReward = -2 # punish the agent ^-^
    else:
        self.currentAction = action
        self.currentReward = 1 # currently unused

        try:
          match action:
            case 0: # right
              self.goRight()

            case 1: # down
              self.goDown()
        except Exception as error:
          print('instruction: ', self.instructions[self.focus_y])
          raise Exception('Error: ', error)

    self.lineReward += self.currentReward
    return self.currentReward

  def calculateScore(self):
    # Execute instructions
    maxScore = 0
    self.winnerVar = -1

    for v in range(0, self.usedStores['b$']):
      score = executeCycles(self.instructions, v)
      if score > maxScore:
        self.winnerVar = v

    self.current_score = maxScore

    if self.maxScore < self.current_score:
      self.maxScoreSurpass = True
      self.maxScore = self.current_score
      self.maxScoreLen = len(self.instructions)
    elif self.maxScore == self.current_score and self.maxScoreLen > len(self.instructions):
      self.maxScoreSurpass = True
      self.maxScoreLen = len(self.instructions)


    if self.current_score == upTo:
      self.game_won = True

  def newLine(self):
    if self.focus_y >= 0:
      # Calculate current score
      self.calculateScore()

    print('Written line: ', self.curLine)

    if self.curLine_isCondition:
      self.newStack()

    self.curLine = []
    self.instructions.append(self.curLine)
    self.endOfLine = 7

    self.focus_x = 0
    self.focus_y += 1

    if self.focus_y >= self.num_lines:
      self.checkGameEnd()

    self.curLine_previousIsStoreTypes = False
    self.curLine_isOperation = False
    self.curLine_isCondition = False
    self.curLine_isAssign = False

    self.totalReward += self.lineReward
    self.lineReward = 0

    self.usedStores = self.lineUsedStores
    self.lineUsedStores = self.usedStores

  def loadOptions_variables(self):
    for t in range(2, len(storeTypes)): # Add just variables
      self.options.append(storeTypes[t])

  def loadOptions_decimal(self):
    for t in range(0, len(storeTypes)): # Add just variables
      if t % 2 == 0:
        self.options.append(storeTypes[t])

  def loadOptions_bool(self):
    for t in range(0, len(storeTypes)): # Add just variables
      if t % 2 == 1:
        self.options.append(storeTypes[t])

  def checkGameEnd(self):
    if self.current_score >= upTo:
      self.game_won = True
    else:
      self.game_won = False

    self.game_over = True

  def getNumStores(self, stype, excepted=0):
    res = len(stores[stype]) + self.usedStores[stype]

    if res < excepted:
      self.lineUsedStores[stype] += 1

    return res

  def loadOptions_Condition(self):
    stores = []

    numVars = self.getNumStores('b$')
    for s in range(0, numVars):
      var = 'b$'+str(s)
      if var in self.storesInAssign and self.storesInAssign[var]:
        stores.append(s)

    return stores

  def countConditionOptions(self):
    return len(self.loadOptions_Condition())

  def loadOptions(self):
    self.options = []
    self.selOption = 0

    hasStore = False
    self.curLine_isAssign = self.focus_x == 1 and self.curLine_previousIsStoreTypes

    # Load available stores
    if self.curLine_previousIsStoreTypes:
      if self.curLine_isAssign:
        for i in self.assignStores[self.curLine_storeType]:
          self.options.append(i)

        if self.depth == 0:
          self.options.append(self.getNumStores(self.curLine_storeType))

      elif self.curLine_isCondition:
        self.options = self.loadOptions_Condition()
      else:
        for i in range(0, self.getNumStores(self.curLine_storeType)):
          self.options.append(i)

    else:
      match self.focus_x:
        case 0:
          self.loadOptions_variables()
          self.options.extend(alternativeStartInstruction)
          hasStore = True

        case 1: # In case of condition
          if self.curLine_isCondition:
            self.options = ['b$']

        case 2: # In case of operation
          self.options.extend(neutralOps)

          if self.curLine_assignIsBool:
            self.options.extend(boolOps)
          else:
            self.options.extend(decimalOps)

          if self.getNumStores(self.curLine_assignType) != self.curLine_assignNum:
            self.options.remove('DEFAULT')

          self.curLine_isOperation = True
          hasStore = True

        case 3:
          match self.curLine_opType:
            case 'n':
              if self.curLine_assignIsBool:
                self.loadOptions_bool()
              else:
                self.loadOptions_decimal()

            case 'b':
              if self.curLine_opReq == 'b':
                  self.loadOptions_bool()
              elif self.curLine_opReq == 'd':
                  self.loadOptions_decimal()
              else:
                  self.options.extend(storeTypes)

            case 'd':
              self.loadOptions_decimal()

            case _:
              print('Wrong curLine_opType: ', self.curLine_opType)

          if not self.curLine_isOperation:
            raise Exception('This line is not an operation...')

          hasStore = True

        case 5:
          if self.curLine_argsAreBool:
            self.loadOptions_bool()
          else:
            self.loadOptions_decimal()

            hasStore = True

      if hasStore:
        remove = []
        for opt in self.options:
          if opt in stores:
            if self.focus_x == 0:
              if self.depth > 0 and len(self.assignStores[opt]) == 0:
                remove.append(opt)
            else:
              if self.getNumStores(opt) == 0:
                remove.append(opt)

        for rem in remove:
          self.options.remove(rem)

    if dontAllowEndOnDepth0 and self.depth <= 0 and not self.maxScoreSurpass:
      if 'END' in self.options:
        self.options.remove('END')

    if 'IF' in self.options and (self.countConditionOptions() == 0):
      self.options.remove('IF')

    if len(self.options) == 0:
      raise Exception("All options excluded...")

    random.shuffle(self.options)

  def newStack(self):
    self.assignStoresStack.append([self.storesInAssign, self.assignStores])
    self.initAssignStores()

  def initAssignStores(self):
    self.storesInAssign = {}
    self.assignStores = {'d$':[], 'b$':[]}

    self.setAsUsedStoreType('d$')
    self.setAsUsedStoreType('b$')

  def setAsUsedStoreType(self, stype):
    for i in range(0, self.getNumStores(stype)):
      self.varIsUsed(stype, i)

  def varIsAssigned(self, stype, var):
    if stype in self.assignStores and var in self.assignStores[stype]:
      self.assignStores[stype].remove(var)
    self.storesInAssign[stype+str(var)] = True

  def varIsUsed(self, stype, var):
    if stype in self.assignStores and var not in self.assignStores[stype]:
      self.assignStores[stype].append(var)
    self.storesInAssign[stype+str(var)] = False

  def oldStack(self):
    pop = self.assignStoresStack.pop()
    self.storesInAssign = pop[0]
    self.assignStores = pop[1]

  def saveOption(self):
    if self.selOption == -1:
      return

    if self.selOption >= len(self.options):
      print('Error on selOption: ', self.focus_x, self.focus_y)
      raise Exception('selOption out of bounds: ', self.selOption, ' in ', self.options);

    opt = self.options[self.selOption]
    self.curLine.append(opt)

    if opt == 'END':
      self.endOfLine = 0

      self.depth -= 1
      if(self.depth < 0):
        self.currentReward = -1
        self.checkGameEnd()
      else:
        self.oldStack()

      return

    if self.curLine_previousIsStoreTypes:
      self.getNumStores(self.curLine_storeType, opt)
      self.currentReward += checkVarReward(self.curLine_storeType, opt)

      if self.curLine_isAssign: # is assignation
        self.varIsAssigned(self.curLine_storeType ,opt)
        self.curLine_assignNum = opt
        self.curLine_isAssign = False
      else:
        self.varIsUsed(self.curLine_storeType, opt)

      self.curLine_previousIsStoreTypes = False
      return

    self.curLine_previousIsStoreTypes = opt in storeTypes

    if self.curLine_previousIsStoreTypes:
        self.currentReward += checkVarReward(opt)
        self.curLine_storeType = opt
        self.curLine_storeIsBool = opt.startswith('b')

    match self.focus_x:
      case 0:
        if self.curLine_previousIsStoreTypes:
          self.curLine_assignIsBool = self.curLine_storeIsBool
          self.curLine_assignType = self.curLine_storeType
        else:
          # In case of condition
          self.curLine_isCondition = True
          self.endOfLine = 2
          self.depth += 1

      case 2:
        if not self.curLine_previousIsStoreTypes:
          self.curLine_opReq = 'NaN'

          if opt in neutralOps:
            self.curLine_opType = 'n'
          elif self.curLine_assignIsBool:
            self.curLine_opType = 'b'

            if opt in boolOps_bool:
                self.curLine_opReq = 'b'

            if opt in boolOps_decimal:
                self.curLine_opReq = 'd'

          else:
            self.curLine_opType = 'd'

          if opt in oneArgOps:
            self.endOfLine = 2

          if opt in neutralOps:
            self.endOfLine = 2

      case 3:
        self.curLine_argsAreBool = self.curLine_storeIsBool

  def goRight(self):
    self.saveOption()

    self.focus_x += 1
    self.endOfLine -= 1

    self.totalReward *= 0.9

    if self.endOfLine < 0 or self.focus_x >= 7:
      self.newLine()

    self.loadOptions()

  def goDown(self):
    self.selOption += 1

    if self.selOption >= len(self.options):
      self.currentReward = -1
      self.selOption -= 1
    else:
      opt = self.options[self.selOption]
      if self.curLine_previousIsStoreTypes:
        self.currentReward += checkVarReward(self.curLine_storeType, opt)
      else:
        if opt in storeTypes:
          self.currentReward += checkVarReward(opt)

  def get_state(self):
    startFrom = 0
    if drawLineNumber:
      startFrom = 1

    # Draw the current view
    canvas = []

    for y in range(0, self.num_lines):
      line = []

      instruction = []
      if y < len(self.instructions):
        instruction = self.instructions[y]

      if drawLineNumber:
        line.append([0, 1, y])

      for x in range(startFrom, self.ideWidth):
        xx = x - startFrom
        pixel = [0, 0, 0]

        def setPixelVal(val):
          isNum = isinstance(val, int)

          if isNum:
            pixel[1] = 1
          else:
            val = labels.index(val)

          pixel[2] = val

        if y == self.focus_y and xx == self.focus_x:
          pixel[0] = 1
          setPixelVal(self.options[self.selOption])

        elif xx < len(instruction):
          setPixelVal(instruction[xx])

        line.append(pixel)

      canvas.append(line)

    return np.array(canvas, dtype=np.uint)

  def get_score(self):
    # Calculate score
    reward = self.lineReward + self.totalReward
    totScore = self.current_score + reward

    print("Score: ", totScore,", ", self.current_score,", ", reward)
    return totScore

  def reset(self):
    self.instructions = []
    self.curLine = ['WELCOME :)']

    self.focus_x = 0
    self.focus_y = -1

    self.game_over = False
    self.game_won = False
    self.maxScoreSurpass = False

    self.depth = 0

    self.current_score = 0

    self.selOption = -1
    self.endOfLine = 0

    self.lineReward = 0
    self.totalReward = 0

    self.usedStores = {'d#':0, 'b#':0, 'd$':0, 'b$':0}
    self.lineUsedStores = self.usedStores
    resetEngine()

    self.assignStoresStack = []
    self.initAssignStores()

    self.curLine_isCondition = False

    # Init first line
    self.currentAction = -1
    self.goRight()

    print('Reset')

  def is_over(self):
    return self.game_over

  def is_won(self):
    return self.game_won

  ### Commands
  def right(self):
    self.play(0)

  def down(self):
    self.play(1)

  def exit(self):
    self.play(2)

"""# Execute"""

### Execution

grid_size = 50
game = Calculon(grid_size)
input_shape = (grid_size, game.ideWidth, 3)

"""## Models

### DenseNet
"""

def getModelDenseNet():

  activation = 'gelu'

  def dense_block(x, growth_rate, num_layers):
      x_in = x  # Input to the dense block
      for _ in range(num_layers):
          # Bottleneck layer
          x = BatchNormalization()(x)
          x = Activation(activation)(x)
          x = Conv2D(growth_rate, kernel_size=(1, 1), padding='same')(x)

          # Composite function
          x = BatchNormalization()(x)
          x = Activation(activation)(x)
          x = Conv2D(growth_rate, kernel_size=(3, 3), padding='same')(x)

          # Concatenate with previous block
          x = Concatenate()([x, x_in])

      return x

  def transition_block(x, compression_factor):
      num_filters = int(x.shape[-1] * compression_factor)

      x = BatchNormalization()(x)
      x = Activation(activation)(x)
      x = Conv2D(num_filters, kernel_size=(1, 1), padding='same')(x)
      x = AveragePooling2D(pool_size=(2, 2), strides=(2, 2))(x)

      return x

  def DenseNet(input_shape, num_blocks=4, num_layers_per_block=4, growth_rate=32, compression_factor=0.5, num_classes=10):
      inputs = Input(shape=input_shape)

      # Initial Convolutional layer
      x = Conv2D(64, kernel_size=(7, 7), strides=(2, 2), padding='same')(inputs)
      x = BatchNormalization()(x)
      x = Activation(activation)(x)
      x = AveragePooling2D(pool_size=(3, 3), strides=(2, 2), padding='same')(x)

      # Dense blocks and transition blocks
      x_in = x
      for i in range(num_blocks):
          x = dense_block(x, growth_rate, num_layers_per_block)
          x_in = transition_block(x, compression_factor)

      # Final blocks
      x = dense_block(x, growth_rate, num_layers_per_block)
      x = BatchNormalization()(x)
      x = Activation(activation)(x)
      x = GlobalAveragePooling2D()(x)

      # Dense layers
      x = Dense(256, activation=activation)(x)
      x = Dense(128, activation=activation)(x)

      # Output layer
      x = Dense(num_classes, activation='linear')(x) # activation='softmax' => sigmoid

      model = Model(inputs, x)
      return model

  model = DenseNet(input_shape=input_shape, num_blocks=3, num_layers_per_block=3, growth_rate=256, compression_factor=0.5, num_classes=2)
  model.compile(optimizer="adam", loss="mean_absolute_error")
  return model

"""### LSTM"""

def getModelLSTM():
  activation = 'gelu'
  lstm_units = 512
  num_lstm_layers = 2

  inputs = Input(shape=input_shape)
  timeSeries = TimeDistributed(LSTM(units=lstm_units, activation=activation), input_shape=input_shape)(inputs)

  # Build a dense block with LSTM layers
  lstm_layers = []
  prev_layer = timeSeries

  for _ in range(num_lstm_layers):
      lstm_layer = LSTM(units=lstm_units, return_sequences=True, activation=activation)(prev_layer)
      lstm_layers.append(lstm_layer)
      prev_layer = Concatenate()([prev_layer, lstm_layer])

  # Dense layers
  prev_layer = Dense(256, activation=activation)(prev_layer)
  prev_layer = Dense(128, activation=activation)(prev_layer)

  # Flatten
  prev_layer = Flatten()(prev_layer)

  # Final output layer
  output = Dense(2, activation='linear')(prev_layer)

  # Create the model
  model = Model(inputs=inputs, outputs=output)

  # Compile the model with appropriate loss, optimizer, and metrics
  model.compile(loss='categorical_crossentropy', optimizer='adam') #, metrics=['accuracy']
  return model

"""## Run"""

model = getModelLSTM()

agent = Agent(model)
agent.train(game)
agent.play(game)

"""# Temporary snippets

## How to correlate to the model hidden information
This is a ChatGPT snippet:
Yes, it is possible to pass additional hidden information, represented as floats, to a Q-learning model alongside the game state represented by an integer matrix. One common approach to handle this situation is to use multiple inputs in a Keras model.

In Keras, you can create a model with multiple input layers, each handling a different type of input data. You can then combine these input layers using different types of layers (e.g., Dense, LSTM, etc.) to build a more complex model that can handle both the game state and the hidden information.

Here's a general outline of how to create a Keras model with multiple inputs:

```python
from keras.models import Model
from keras.layers import Input, Dense, concatenate

# Assuming game state is represented as an integer matrix of shape (game_rows, game_cols)
game_input = Input(shape=(game_rows, game_cols), name='game_input')

# Assuming hidden information is represented as a float vector of shape (hidden_dim,)
hidden_info_input = Input(shape=(hidden_dim,), name='hidden_info_input')

# Add layers to process the game state and hidden information
# Example: flatten the game input and add some Dense layers for game processing
game_processed = Flatten()(game_input)
game_processed = Dense(64, activation='relu')(game_processed)

# Example: add some Dense layers for hidden information processing
hidden_info_processed = Dense(32, activation='relu')(hidden_info_input)

# Combine the processed game state and hidden information using concatenate
combined = concatenate([game_processed, hidden_info_processed])

# Add more layers as needed for the Q-learning model
# Example: Dense output layer for Q-values
q_values = Dense(num_actions, activation='linear')(combined)

# Create the model with the specified inputs and outputs
model = Model(inputs=[game_input, hidden_info_input], outputs=q_values)

# Compile the model and define the loss and optimizer as needed
model.compile(optimizer='adam', loss='mse')

# Train the model using appropriate data for both inputs
# Example: game_data and hidden_info_data are the training data for game state and hidden information, respectively
model.fit([game_data, hidden_info_data], q_values_data, epochs=...)
```

In this example, we create two input layers, one for the game state and the other for the hidden information. We process each input using different layers (Dense in this case), and then concatenate the processed outputs. Finally, we continue with more layers and an output layer to produce the Q-values.

When training the model, you will need to provide appropriate training data for both the game state and hidden information inputs, along with the corresponding target Q-values.

Remember to preprocess your data appropriately before feeding it into the model. The specific architecture and hyperparameters will depend on the complexity of your game and the nature of the hidden information.

## Inspirations

### BigFloat
Exists a library in Python able to create floating point variable with dynamic precision: https://pypi.org/project/bigfloat/
"""